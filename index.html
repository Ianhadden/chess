<!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
	
	<center>
	<font face="Courier New, serif" size="6">
	<form id="moveInput">
	Move: <input name="name" type="text" size="20" onkeypress="handle(event)">
	</form>
	</font>
	<!--<button onclick="getMoveInput()">Submit</button>-->
	</center>
	
	<p id="info1"><br></p>
	<p id="info2">Lowercase's move</p>
	<p><br></p>
	<p id="8"></p>
	<p id="7"></p>
	<p id="6"></p>
	<p id="5"></p>
	<p id="4"></p>
	<p id="3"></p>
	<p id="2"></p>
	<p id="1"></p>
	<p id="b"></p>
	
	<p id="b2"></p>
	
<script>
var boardy = new Board();
printBoard(boardy);
var wkPosition = new Position(1, 5);
var bkPosition = new Position(8, 5);
var stillGoing = true;
function handle(e){
	if(e.keyCode === 13){
		getMoveInput();
		e.preventDefault();
	}
	return false;
}
// Reads input from the textbox and applies the move if valid, switching
// whose turn it is. Checks for checks, checkmates, etc.
function getMoveInput(){
	if (stillGoing){
		var moveForm = document.getElementById("moveInput");
		var moveText = moveForm.elements["name"].value;
		//check for correct string format
		if (moveText.length !== 5|| moveText.substring(2, 3) !== " "){
			document.getElementById("info1").innerHTML="Invalid command";
		} else {
			//parse for start and end positions, check if they are valid
			var startPosition = getCoordsFromInput(moveText.substring(0,2));
			var endPosition = getCoordsFromInput(moveText.substring(3, 5));
			if (startPosition.x === -1 || startPosition.y === -1
				|| endPosition.x === -1 || endPosition.y === -1){
				document.getElementById("info1").innerHTML="Invalid position(s)";
			} else {
				//check if the movement itself is valid
				var valid = checkMoveValidity(startPosition, endPosition);
				
				if (valid){
				
					validMoveProcedure(startPosition, endPosition, moveForm, moveText);
					
					printBoard(boardy);
					if ((boardy.turn === "white") && stillGoing){
						document.getElementById("info2").innerHTML="Lowercase's move";
					} else if (stillGoing){
						document.getElementById("info2").innerHTML="Uppercase's move";
					}
					
				} else {
					document.getElementById("info1").innerHTML="Invalid Move";
				}
			}
		}
	}
	return false;
}

function validMoveProcedure(startPosition, endPosition, moveForm, moveText){
	var piece = boardy.grid[startPosition.y][startPosition.x];
	var target = boardy.grid[endPosition.y][endPosition.x];
	var playerMakingMove = boardy.turn;
	
	//apply move, see if put self in check
	applyMove(startPosition, endPosition);
	var putSelfInCheck = playerInCheck(playerMakingMove);
	
	if (putSelfInCheck){
		//if put self in check, undo move
		undoMove(startPosition, endPosition, target);
		document.getElementById("info1").innerHTML="Invalid Move, put's you in check";
	} else {
		//otherwise, don't undo, update stuff accordingly.
		//see if we put the other person in check
		document.getElementById("info1").innerHTML="Last move was " + moveText;
		moveForm.elements["name"].value = "";
		var putOtherInCheck = playerInCheck(boardy.turn);
		if (putOtherInCheck){
			document.getElementById("b2").innerHTML="CHECK!";
			if (checkMate(boardy.turn)){

				//we have a winner
				stillGoing = false;
				document.getElementById("b2").innerHTML="CHECKMATE!";
				var winner;
				if (boardy.turn === "white"){
					winner = "Uppercase";
				} else {
					winner = "Lowercase";
				}
				document.getElementById("info2").innerHTML = winner + " wins!";
			}
		} else if (stalemate(boardy.turn)){
			stillGoing = false;
			document.getElementById("b2").innerHTML="Stalemate!";
			document.getElementById("info2").innerHTML = "It's a draw";
			
		} else {
			document.getElementById("b2").innerHTML="";
		}
	}
}

// Checks if a move is valid or not based on owner and what sort of piece it is
function checkMoveValidity(startPosition, endPosition){ //obviously incomplete
	var piece = boardy.grid[startPosition.y][startPosition.x];
	var target = boardy.grid[endPosition.y][endPosition.x];
	if (piece.owner !== boardy.turn || !piece.validMove(endPosition)){
		return false;
	}
	return true;
}

//returns true if the given player is in check
function playerInCheck(player){
	var correctTurn = boardy.turn;
	var kingPos;
	
	//gets the king position of the player in question.
	//switches whose turn it is to the opposing player temporarily in order to test
	if (player === "white"){
		kingPos = wkPosition;
		boardy.turn = "black";
	} else {
		kingPos = bkPosition;
		boardy.turn = "white";
	}
	//see if any position of the board can successfully attack the king
	for (var i = 1; i < 9; i++){
		for (var j = 1; j < 9; j++){
			if (checkMoveValidity(new Position(i, j), kingPos)){
				boardy.turn = correctTurn;
				return true;
			}
		}
	}
	boardy.turn = correctTurn;
	return false;
}
//returns true if the given player has lost
function checkMate(player){
	return (playerInCheck(player) && everyMoveIsCheck(player));
}

//returns true if the player is in a stalemate position
function stalemate(player){
	return (!(playerInCheck(player)) && everyMoveIsCheck(player));
}

//returns true if every move a player could make puts them in check
function everyMoveIsCheck(player){
	var playersPieces = new Array();
	//get all their pieces
	for (var i = 1; i < 9; i++){
		for (var j = 1; j < 9; j++){
			if (boardy.grid[i][j].owner === player){
				playersPieces.push(boardy.grid[i][j]);
			}
		}
	}
	//for each piece, test validity of moving to every spot on the board
	//If it's valid, try applying that move, and see if the player is in check
	//Return true if every one is check
	for (var m = 0; m < playersPieces.length; m++){
		for (var i = 1; i < 9; i++){
			for (var j = 1; j < 9; j++){
				if (checkMoveValidity(playersPieces[m].position, new Position(i, j))){
					var startPos = new Position(playersPieces[m].position.y, playersPieces[m].position.x);
					var endPos = new Position(i, j);
					var target = boardy.grid[endPos.y][endPos.x];
					applyMove(startPos, endPos);
					if (!playerInCheck(player)){
						undoMove(startPos, endPos, target);
						return false;
					} else {
						undoMove(startPos, endPos, target);
					}
				}
			}
		}
	}
	return true;
}

//applies the move on the board, flipping whose turn it is. Updates the king's global
//position if necessary
function applyMove(startPosition, endPosition){
	
	if (boardy.grid[startPosition.y][startPosition.x] instanceof King &&
		((startPosition.x - endPosition.x === 2) || (startPosition.x - endPosition.x === -2))){
		//castling
		castleApplyMove(startPosition, endPosition);
	} else {
		//normal move
		standardApplyMove(startPosition, endPosition);
	}
	
	if (boardy.grid[endPosition.y][endPosition.x] instanceof King){
		if (boardy.turn === "white"){
			wkPosition.x = endPosition.x;
			wkPosition.y = endPosition.y;
		} else {
			bkPosition.x = endPosition.x;
			bkPosition.y = endPosition.y;
		}
	}
	
	if (boardy.turn === "white"){
		boardy.turn = "black";
	} else {
		boardy.turn = "white";
	}
	//printBoard(boardy);
}

function standardApplyMove(startPosition, endPosition){
	boardy.grid[endPosition.y][endPosition.x] = boardy.grid[startPosition.y][startPosition.x];
	boardy.grid[startPosition.y][startPosition.x] = 
	new Empty("empty", boardy, new Position(startPosition.y, startPosition.x));
	var movedPiece = boardy.grid[endPosition.y][endPosition.x];
	movedPiece.position.y = endPosition.y;
	movedPiece.position.x = endPosition.x;
	
	//update hasMoved if applicable
	if (movedPiece instanceof King || movedPiece instanceof Rook){
		movedPiece.hasMoved[0] = movedPiece.hasMoved[1];
		movedPiece.hasMoved[1] = true;
	}
}

function castleApplyMove(startPosition, endPosition){
	
	//move king
	standardApplyMove(startPosition, endPosition);
	document.getElementById("info1").innerHTML="derpy5";
	//move rook, update hasMoved
	var rook;
	if (endPosition.x - startPosition.x === 2){
		document.getElementById("info1").innerHTML="derpy6";
		rook = boardy.grid[endPosition.y][endPosition.x + 1];
		document.getElementById("info1").innerHTML="derpy7";
		standardApplyMove(new Position(rook.position.y, rook.position.x), 
						new Position(rook.position.y, rook.position.x - 2));
		document.getElementById("info1").innerHTML="derpy8";
	} else { //endPosition.x - startPosition.x === -2
		rook = boardy.grid[endPosition.y][endPosition.x - 2];
		standardApplyMove(new Position(rook.position.y, rook.position.x), 
						new Position(rook.position.y, rook.position.x + 3));
	}
	
}


//After a move has been made, if the player that made that move is in check,
//it wasn't actually valid, so we undo it. Function takes the start position
//and end position of said move, as well as whatever piece was taken (or Empty),
//and puts them back in their proper places. Switches whose turn it is back also.
function undoMove(startPosition, endPosition, target){
	
	if (boardy.grid[endPosition.y][endPosition.x] instanceof King &&
		((startPosition.x - endPosition.x === 2) || (startPosition.x - endPosition.x === -2))){
		//castling
		castleUndoMove(startPosition, endPosition, target);
	} else {
		//normal move
		standardUndoMove(startPosition, endPosition, target);
	}
	
	if (boardy.turn === "white"){
		boardy.turn = "black";
	} else {
		boardy.turn = "white";
	}
	
	if (boardy.grid[startPosition.y][startPosition.x] instanceof King){
		if (boardy.turn === "white"){
			wkPosition.x = startPosition.x;
			wkPosition.y = startPosition.y;
		} else {
			bkPosition.x = startPosition.x;
			bkPosition.y = startPosition.y;
		}
	}
}

function standardUndoMove(startPosition, endPosition, target){
	boardy.grid[startPosition.y][startPosition.x] = boardy.grid[endPosition.y][endPosition.x];
	boardy.grid[endPosition.y][endPosition.x] = target;
	var unMovedPiece = boardy.grid[startPosition.y][startPosition.x];
	unMovedPiece.position.y = startPosition.y;
	unMovedPiece.position.x = startPosition.x;
	
	if (unMovedPiece instanceof King || unMovedPiece instanceof Rook){
		unMovedPiece.hasMoved[1] = unMovedPiece.hasMoved[0];
	}
}

function castleUndoMove(startPosition, endPosition, target){
	standardUndoMove(startPosition, endPosition, target);
	var rook;
	if (endPosition.x - startPosition.x === 2){
		rook = boardy.grid[startPosition.y][startPosition.x + 1];
		standardUndoMove(new Position(rook.position.y, rook.position.x + 2),
						new Position(rook.position.y, rook.position.x), 
						new Empty("empty", new Position(rook.position.y, rook.position.x)));
						
	} else { //endPosition.x - startPosition.x === -2
		rook = boardy.grid[startPosition.y][startPosition.x - 1];
		standardUndoMove(new Position(rook.position.y, rook.position.x - 3),
						new Posiion(rook.position.y, rook.position.x),
						new Empty("empty", new Position(rook.position.y, rook.position.x)));
		
	}
}

//parses string input ("a4" for instance) to get coordinates on the board,
//which are returned as a position pair
function getCoordsFromInput(stringInput){
	var stringX = stringInput.substring(0, 1);
	var stringY = stringInput.substring(1, 2);
	var numX, numY;
	switch (stringX) {
		case "a":
			numX = 1;
			break;
		case "b":
			numX = 2;
			break;
		case "c":
			numX = 3;
			break;
		case "d":
			numX = 4;
			break;
		case "e":
			numX = 5;
			break;
		case "f":
			numX = 6;
			break;
		case "g":
			numX = 7;
			break;
		case "h":
			numX = 8;
			break;
		default:
			numX = -1;
	}
	switch (stringY) {
		case "1":
			numY = 1;
			break;
		case "2":
			numY = 2;
			break;
		case "3":
			numY = 3;
			break;
		case "4":
			numY = 4;
			break;
		case "5":
			numY = 5;
			break;
		case "6":
			numY = 6;
			break;
		case "7":
			numY = 7;
			break;
		case "8":
			numY = 8;
			break;
		default:
			numY = -1;
	}
	var position = new Position(numY, numX);
	return position;
}
//prints the given board
function printBoard(board){
	document.getElementById("8").innerHTML = getBoardRow(board, 8);
	document.getElementById("7").innerHTML = getBoardRow(board, 7);
	document.getElementById("6").innerHTML = getBoardRow(board, 6);
	document.getElementById("5").innerHTML = getBoardRow(board, 5);
	document.getElementById("4").innerHTML = getBoardRow(board, 4);
	document.getElementById("3").innerHTML = getBoardRow(board, 3);
	document.getElementById("2").innerHTML = getBoardRow(board, 2);
	document.getElementById("1").innerHTML = getBoardRow(board, 1);
	document.getElementById("b").innerHTML = "<b>" + board.grid[0] + "</b>";
}
//returns a row of a board as a string
function getBoardRow(board, row){
	var ret = "<b>" + row + "</b>";
	for (var i = 1; i < 9; i++){
		ret += " ";
		ret += getDisplay(board.grid[row][i]);
	}
	return ret;
}
//Creates a new board, initialized with pieces in starting positions
function Board(){
	this.grid = new Array();
	this.grid[0] = "0 a b c d e f g h";
	this.grid[1] = new Array();
	this.grid[1][0] = 1;
	fillRowWithPieces("white", 1, this);
	this.grid[2] = new Array();
	this.grid[2][0] = 2;
	fillRowWithPawns("white", 2, this);
	this.grid[3] = new Array();
	this.grid[3][0] = 3;
	fillRowWithEmpty(3, this);
	this.grid[4] = new Array();
	this.grid[4][0] = 4;
	fillRowWithEmpty(4, this);
	this.grid[5] = new Array();
	this.grid[5][0] = 5;
	fillRowWithEmpty(5, this);
	this.grid[6] = new Array();
	this.grid[6][0] = 3;
	fillRowWithEmpty(6, this);
	this.grid[7] = new Array();
	this.grid[7][0] = 7;
	fillRowWithPawns("black", 7, this);
	this.grid[8] = new Array();
	this.grid[8][0] = 8;
	fillRowWithPieces("black", 8, this);
	this.turn = "white";
}
//Fills the given row on the given board with Pawns belonging to the given owner
function fillRowWithPawns(owner, row, board){
	for (var i = 1; i < 9; i++){
		board.grid[row][i] = new Pawn(owner, new Position(row, i));
	}
}
//Fills the given row on the given board with empty spaces
function fillRowWithEmpty(row, board){
	for (var i = 1; i < 9; i++){
		board.grid[row][i] = new Empty("empty", new Position(row, i));
	}
}
//Fills the given row on the given board with Pawn, Horse, Bishop, etc, belonging
//to the given owner
function fillRowWithPieces(owner, row, board){
	board.grid[row][1] = new Rook(owner, new Position(row, 1));
	board.grid[row][2] = new Horse(owner, new Position(row, 2));
	board.grid[row][3] = new Bishop(owner, new Position(row, 3));
	board.grid[row][4] = new Queen(owner, new Position(row, 4));
	board.grid[row][5] = new King(owner, new Position(row, 5));
	board.grid[row][6] = new Bishop(owner, new Position(row, 6));
	board.grid[row][7] = new Horse(owner, new Position(row, 7));
	board.grid[row][8] = new Rook(owner, new Position(row, 8));
}
//Takes in a piece object and returns how that piece should be displayed as a string
function getDisplay(piece){
	var ret;
	if (piece instanceof Empty){ //piece.owner
		ret = "-";
	} else if (piece instanceof Rook){
		ret = "r";
	} else if (piece instanceof Horse){
		ret = "h";
	} else if (piece instanceof Bishop){
		ret = "b";
	} else if (piece instanceof Queen){
		ret = "q";
	} else if (piece instanceof King){
		ret = "k";
	} else if (piece instanceof Pawn){
		ret = "p";
	} else {
		ret = "v";
	}
	if (piece.owner === "black"){
		ret = ret.toUpperCase();
	}
	return ret;
}
//Creates a position pair. Notice the unusual ordering (y, x)
function Position(y, x){
	this.x = x;
	this.y = y;
}
function Piece(owner, position){
	this.owner = owner;
	this.position = position;
	this.validMove = function(){};
}
function Rook(owner, position){
	this.owner = owner;
	this.position = position;
	this.hasMoved = [false, false];
	this.validMove = function(endPosition){
		if (position.x === endPosition.x){
		//vertical movement
		
			var yDif = endPosition.y - position.y;
			if (yDif > 0){
				//moving upward on board
				
				for (var i = 1; i < yDif; i++){
					if (!(boardy.grid[i + position.y][position.x] instanceof Empty)){
						return false;
					}
				}
				if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
				return false;
			} else {
				//moving downward on board
				yDif = -1 * yDif;
				for (var i = 1; i < yDif; i++){
					if (!(boardy.grid[position.y - i][position.x] instanceof Empty)){
						return false;
					}
				}
				if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
				return false;
			}
		} else if (position.y === endPosition.y){
		//horizontal movement
			
			var xDif = endPosition.x - position.x;
			if (xDif > 0){
				//moving right on board
				
				for (var i = 1; i < xDif; i++){
					if(!(boardy.grid[position.y][i + position.x] instanceof Empty)){
						return false;
					}
				}
				if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
				return false;
			} else {
				//moving left on board
				xDif = -1 * xDif;
				for (var i = 1; i < xDif; i++){
					if (!(boardy.grid[position.y][position.x - i] instanceof Empty)){
						return false;
					}
				}
				if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
				return false;
			}
		} else {
			return false;
		}
	};
}
function Horse(owner, position){
	this.owner = owner;
	this.position = position;
	this.validMove = function(endPosition){
		var xDif = endPosition.x - position.x;
		var yDif = endPosition.y - position.y;
		if (((yDif === 2 || yDif === -2) && (xDif === 1 || xDif === -1))
			|| ((yDif === 1 || yDif === -1) && (xDif === 2 || xDif === -2))){
			if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
				return true;
			}
			return false;
		}
		return false;
	};
}
function Bishop(owner, position){
	this.owner = owner;
	this.position = position;
	this.validMove = function(endPosition){
		var yDif = endPosition.y - position.y;
		var xDif = endPosition.x - position.x;
		if (yDif > 0 && xDif > 0 && xDif === yDif){
			//up-right movement
			for (var i = 1; i < yDif; i++){
				if (!(boardy.grid[position.y + i][position.x + i] instanceof Empty)){
					return false;
				}
			}
			if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
			return false;
			
		} else if (yDif > 0 && xDif < 0 && xDif * -1 === yDif){
			//up-left movement
			
			for (var i = 1; i < yDif; i++){
				if (!(boardy.grid[position.y + i][position.x - i] instanceof Empty)){
					return false;
				}
			}
			if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
			return false;
			
		} else if (yDif < 0 && xDif < 0 && xDif === yDif){
			//down-left movement
			
			for (var i = 1; i < yDif * -1; i++){
				if (!(boardy.grid[position.y - i][position.x - i] instanceof Empty)){
					return false;
				}
			}
			if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
			return false;
			
		} else if (yDif < 0 && xDif > 0 && xDif === yDif * -1){
			//down-right movement
			
			for (var i = 1; i < xDif; i++){
				if (!(boardy.grid[position.y - i][position.x + i] instanceof Empty)){
					return false;
				}
			}
			if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
			return false;
		} else {
			return false;
		}
	};
}
function Queen(owner, position){
	this.owner = owner;
	this.position = position;
	this.validMove = function(endPosition){
		if (position.x === endPosition.x){
		//vertical movement
		
			var yDif = endPosition.y - position.y;
			if (yDif > 0){
				//moving upward on board
				
				for (var i = 1; i < yDif; i++){
					if (!(boardy.grid[i + position.y][position.x] instanceof Empty)){
						return false;
					}
				}
				if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
				return false;
			} else {
				//moving downward on board
				yDif = -1 * yDif;
				for (var i = 1; i < yDif; i++){
					if (!(boardy.grid[position.y - i][position.x] instanceof Empty)){
						return false;
					}
				}
				if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
				return false;
			}
		} else if (position.y === endPosition.y){
		//horizontal movement
			
			var xDif = endPosition.x - position.x;
			if (xDif > 0){
				//moving right on board
				
				for (var i = 1; i < xDif; i++){
					if(!(boardy.grid[position.y][i + position.x] instanceof Empty)){
						return false;
					}
				}
				if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
				return false;
			} else {
				//moving left on board
				xDif = -1 * xDif;
				for (var i = 1; i < xDif; i++){
					if (!(boardy.grid[position.y][position.x - i] instanceof Empty)){
						return false;
					}
				}
				if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
				return false;
			}
		} else {
			var yDif = endPosition.y - position.y;
			var xDif = endPosition.x - position.x;
			if (yDif > 0 && xDif > 0 && xDif === yDif){
				//up-right movement
				for (var i = 1; i < yDif; i++){
					if (!(boardy.grid[position.y + i][position.x + i] instanceof Empty)){
						return false;
					}
				}
				if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
						return true;
					}
				return false;
				
			} else if (yDif > 0 && xDif < 0 && xDif * -1 === yDif){
				//up-left movement
				
				for (var i = 1; i < yDif; i++){
					if (!(boardy.grid[position.y + i][position.x - i] instanceof Empty)){
						return false;
					}
				}
				if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
						return true;
					}
				return false;
				
			} else if (yDif < 0 && xDif < 0 && xDif === yDif){
				//down-left movement
				
				for (var i = 1; i < yDif * -1; i++){
					if (!(boardy.grid[position.y - i][position.x - i] instanceof Empty)){
						return false;
					}
				}
				if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
						return true;
					}
				return false;
				
			} else if (yDif < 0 && xDif > 0 && xDif === yDif * -1){
				//down-right movement
				
				for (var i = 1; i < xDif; i++){
					if (!(boardy.grid[position.y - i][position.x + i] instanceof Empty)){
						return false;
					}
				}
				if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
						return true;
					}
				return false;
			} else {
				return false;
			}
		}
	};
}
function King(owner, position){
	this.owner = owner;
	this.position = position;
	this.hasMoved = [false, false];
	this.validMove = function(endPosition){
		var xDif = endPosition.x - position.x;
		var yDif = endPosition.y - position.y;
		if (yDif === 0 && (xDif === 2 || xDif === -2)){
			//castling
			var rook;
			if (xDif === 2){
				rook = boardy.grid[position.y][position.x + 3];
				if (!(boardy.grid[position.y][position.x + 1] instanceof Empty) ||
					!(boardy.grid[position.y][position.x + 2] instanceof Empty)){
						return false;
					}
			} else { //xDif === -2
				rook = boardy.grid[position.y][position.x - 4];
				if (!(boardy.grid[position.y ][position.x - 1] instanceof Empty) ||
					!(boardy.grid[position.y ][position.x - 2] instanceof Empty) ||
					!(boardy.grid[position.y][position.x - 3] instanceof Empty)){
					return false;
				}
			}

			if (!(rook instanceof Rook) || !(rook.owner === owner) || rook.hasMoved[1] || this.hasMoved[1]){
				return false;
			}
			return true;
		}
		
		if (!(xDif === -1 || xDif === 1 || xDif === 0)){
			return false;
		}
		if (!(yDif === -1 || yDif === 1 || yDif === 0)){
			return false;
		}
		if (xDif === 0 && yDif === 0){
			return false;
		}
		if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
			return true;
		}
		return false;
	};
}

function Pawn(owner, position){
	this.owner = owner;
	this.position = position;
	this.validMove = function(endPosition){
		if (owner === "white"){
			if (position.x === endPosition.x){
				//non attack move
				if (position.y + 1 === endPosition.y 
					&& boardy.grid[endPosition.y][endPosition.x] instanceof Empty){
					//normal move
					return true;
					
				} else if (position.y + 2 === endPosition.y 
							&& boardy.grid[endPosition.y - 1][endPosition.x] instanceof Empty
							&& boardy.grid[endPosition.y][endPosition.x] instanceof Empty
							&& position.y === 2){
					//special 2 space move
					return true;
				} else {
					return false;
				}
			} else if ((position.y + 1 === endPosition.y && position.x - 1 === endPosition.x) ||
						(position.y + 1 === endPosition.y && position.x + 1 === endPosition.x)){
				//attack move
				
				if (boardy.grid[endPosition.y][endPosition.x].owner === "black"){
					return true;
				} else {
					return false;
				}
			} else{
				return false;
			}
		} else { //owner is black
			if (position.x === endPosition.x){
				//non attack move
				
				if (position.y - 1 === endPosition.y 
					&& boardy.grid[endPosition.y][endPosition.x] instanceof Empty){
					//normal move
					return true;
					
				} else if (position.y - 2 === endPosition.y 
							&& boardy.grid[endPosition.y + 1][endPosition.x] instanceof Empty
							&& boardy.grid[endPosition.y][endPosition.x] instanceof Empty
							&& position.y === 7){
					//special 2 space move
					return true;
				} else {
					return false;
				}
			} else if ((position.y - 1 === endPosition.y && position.x - 1 === endPosition.x) ||
						(position.y - 1 === endPosition.y && position.x + 1 === endPosition.x)){
				//attack move
				
				if (boardy.grid[endPosition.y][endPosition.x].owner === "white"){
					return true;
				} else {
					return false;
				}
			} else{
				return false;
			}
		}
	};
}
function Empty(owner, board, position){
	this.board = board;
	this.owner = owner;
	this.position = position;
	this.validMove = function(endPosition){
		return false;
	};
}
</script>

<!--
	<p id="8">8   R H B Q K B H R</p>
	<p id="7">7   P P P P P P P P</p>
	<p id="6">6   - - - - - - - -</p>
	<p id="5">5   - - - - - - - -</p>
	<p id="4">4   - - - - - - - -</p>
	<p id="3">3   - - - - - - - -</p>
	<p id="2">2   p p p p p p p p</p>
	<p id="1">1   r h b q k b h r</p>
	<p id="b">0   a b c d e f g h</p>
-->
</body>
</html>