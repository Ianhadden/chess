<!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
	
	<center>
	<font face="Courier New, serif" size="6">
	<form id="moveInput">
	Move: <input name="name" type="text" size="20" onkeypress="handle(event)">
	</form>
	</font>
	<!--<button onclick="getMoveInput()">Submit</button>-->
	</center>
	
	<p id="info1"><br></p>
	<p id="info2">Lowercase's move</p>
	<p><br></p>
	<p id="8"></p>
	<p id="7"></p>
	<p id="6"></p>
	<p id="5"></p>
	<p id="4"></p>
	<p id="3"></p>
	<p id="2"></p>
	<p id="1"></p>
	<p id="b"></p>
	
	<p id="b2"></p>
	
<script>

var boardy = new Board();
printBoard(boardy);

function handle(e){
	if(e.keyCode === 13){
		getMoveInput();
		e.preventDefault();
	}
	return false;
}


// Reads input from the textbox and applies the move if valid, switching
// whose turn it is
function getMoveInput(){
	var moveForm = document.getElementById("moveInput");
	var moveText = moveForm.elements["name"].value;
	if (moveText.length !== 5|| moveText.substring(2, 3) !== " "){
		document.getElementById("info1").innerHTML="Invalid command";
	} else {
		var startPosition = getCoordsFromInput(moveText.substring(0,2));
		var endPosition = getCoordsFromInput(moveText.substring(3, 5));
		if (startPosition.x === -1 || startPosition.y === -1
			|| endPosition.x === -1 || endPosition.y === -1){
			document.getElementById("info1").innerHTML="Invalid position(s)";
		} else {
			document.getElementById("info1").innerHTML="derpy";
			var valid = checkMoveValidity(startPosition, endPosition);
			document.getElementById("info1").innerHTML="derpy50";
			if (valid){
				applyMove(startPosition, endPosition);
				document.getElementById("info1").innerHTML="Last move was " + moveText;
				moveForm.elements["name"].value = ""; //test
			} else {
				document.getElementById("info1").innerHTML="Invalid Move";
			}
		}
		//document.getElementById("info1").innerHTML="start position: " + startPosition.x + startPosition.y;
	}
	return false;
}

// Checks if a move is valid or not based on owner and what sort of piece it is
function checkMoveValidity(startPosition, endPosition){ //obviously incomplete
	var piece = boardy.grid[startPosition.y][startPosition.x];
	var target = boardy.grid[endPosition.y][endPosition.x];
	document.getElementById("info1").innerHTML="derpy3";
	if (piece.owner !== boardy.turn || !piece.validMove(endPosition)){
		return false;
	}
	return true;
}

//applies the move on the board, flipping whose turn it is
function applyMove(startPosition, endPosition){
	boardy.grid[endPosition.y][endPosition.x] = boardy.grid[startPosition.y][startPosition.x];
	boardy.grid[startPosition.y][startPosition.x] = 
		new Empty("empty", boardy, new Position(startPosition.y, startPosition.x));
	boardy.grid[endPosition.y][endPosition.x].position.y = endPosition.y;
	boardy.grid[endPosition.y][endPosition.x].position.x = endPosition.x;
	if (boardy.turn === "white"){
		boardy.turn = "black";
		document.getElementById("info2").innerHTML="Uppercase's move";
	} else {
		boardy.turn = "white";
		document.getElementById("info2").innerHTML="Lowercase's move";
	}
	printBoard(boardy);
}

//parses string input ("a4" for instance) to get coordinates on the board,
//which are returned as a position pair
function getCoordsFromInput(stringInput){
	var stringX = stringInput.substring(0, 1);
	var stringY = stringInput.substring(1, 2);
	var numX, numY;
	switch (stringX) {
		case "a":
			numX = 1;
			break;
		case "b":
			numX = 2;
			break;
		case "c":
			numX = 3;
			break;
		case "d":
			numX = 4;
			break;
		case "e":
			numX = 5;
			break;
		case "f":
			numX = 6;
			break;
		case "g":
			numX = 7;
			break;
		case "h":
			numX = 8;
			break;
		default:
			numX = -1;
	}
	switch (stringY) {
		case "1":
			numY = 1;
			break;
		case "2":
			numY = 2;
			break;
		case "3":
			numY = 3;
			break;
		case "4":
			numY = 4;
			break;
		case "5":
			numY = 5;
			break;
		case "6":
			numY = 6;
			break;
		case "7":
			numY = 7;
			break;
		case "8":
			numY = 8;
			break;
		default:
			numY = -1;
	}
	var position = new Position(numY, numX);
	return position;
}

//prints the given board
function printBoard(board){
	document.getElementById("8").innerHTML = getBoardRow(board, 8);
	document.getElementById("7").innerHTML = getBoardRow(board, 7);
	document.getElementById("6").innerHTML = getBoardRow(board, 6);
	document.getElementById("5").innerHTML = getBoardRow(board, 5);
	document.getElementById("4").innerHTML = getBoardRow(board, 4);
	document.getElementById("3").innerHTML = getBoardRow(board, 3);
	document.getElementById("2").innerHTML = getBoardRow(board, 2);
	document.getElementById("1").innerHTML = getBoardRow(board, 1);
	document.getElementById("b").innerHTML = "<b>" + board.grid[0] + "</b>";
}

//returns a row of a board as a string
function getBoardRow(board, row){
	var ret = "<b>" + row + "</b>";
	for (var i = 1; i < 9; i++){
		ret += " ";
		ret += getDisplay(board.grid[row][i]);
	}
	return ret;
}

//Creates a new board, initialized with pieces in starting positions
function Board(){
	this.grid = new Array();
	this.grid[0] = "0 a b c d e f g h";
	this.grid[1] = new Array();
	this.grid[1][0] = 1;
	fillRowWithPieces("white", 1, this);
	this.grid[2] = new Array();
	this.grid[2][0] = 2;
	fillRowWithPawns("white", 2, this);
	this.grid[3] = new Array();
	this.grid[3][0] = 3;
	fillRowWithEmpty(3, this);
	this.grid[4] = new Array();
	this.grid[4][0] = 4;
	fillRowWithEmpty(4, this);
	this.grid[5] = new Array();
	this.grid[5][0] = 5;
	fillRowWithEmpty(5, this);
	this.grid[6] = new Array();
	this.grid[6][0] = 3;
	fillRowWithEmpty(6, this);
	this.grid[7] = new Array();
	this.grid[7][0] = 7;
	fillRowWithPawns("black", 7, this);
	this.grid[8] = new Array();
	this.grid[8][0] = 8;
	fillRowWithPieces("black", 8, this);
	this.turn = "white";
}

//Fills the given row on the given board with Pawns belonging to the given owner
function fillRowWithPawns(owner, row, board){
	for (var i = 1; i < 9; i++){
		board.grid[row][i] = new Pawn(owner, new Position(row, i));
	}
}

//Fills the given row on the given board with empty spaces
function fillRowWithEmpty(row, board){
	for (var i = 1; i < 9; i++){
		board.grid[row][i] = new Empty("empty", new Position(row, i));
	}
}

//Fills the given row on the given board with Pawn, Horse, Bishop, etc, belonging
//to the given owner
function fillRowWithPieces(owner, row, board){
	board.grid[row][1] = new Rook(owner, new Position(row, 1));
	board.grid[row][2] = new Horse(owner, new Position(row, 2));
	board.grid[row][3] = new Bishop(owner, new Position(row, 3));
	board.grid[row][4] = new Queen(owner, new Position(row, 4));
	board.grid[row][5] = new King(owner, new Position(row, 5));
	board.grid[row][6] = new Bishop(owner, new Position(row, 6));
	board.grid[row][7] = new Horse(owner, new Position(row, 7));
	board.grid[row][8] = new Rook(owner, new Position(row, 8));
}

//Takes in a piece object and returns how that piece should be displayed as a string
function getDisplay(piece){
	var ret;
	if (piece instanceof Empty){ //piece.owner
		ret = "-";
	} else if (piece instanceof Rook){
		ret = "r";
	} else if (piece instanceof Horse){
		ret = "h";
	} else if (piece instanceof Bishop){
		ret = "b";
	} else if (piece instanceof Queen){
		ret = "q";
	} else if (piece instanceof King){
		ret = "k";
	} else if (piece instanceof Pawn){
		ret = "p";
	} else {
		ret = "v";
	}
	if (piece.owner === "black"){
		ret = ret.toUpperCase();
	}
	return ret;
}

//Creates a position pair. Notice the unusual ordering (y, x)
function Position(y, x){
	this.x = x;
	this.y = y;
}

function Piece(owner, position){
	this.owner = owner;
	this.position = position;
	this.validMove = function(){};
}

function Rook(owner, position){
	this.owner = owner;
	this.position = position;
	this.validMove = function(endPosition){
		if (position.x === endPosition.x){
		//vertical movement
		
			var yDif = endPosition.y - position.y;
			if (yDif > 0){
				//moving upward on board
				
				for (var i = 1; i < yDif; i++){
					if (!(boardy.grid[i + position.y][position.x] instanceof Empty)){
						return false;
					}
				}
				if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
				return false;
			} else {
				//moving downward on board
				yDif = -1 * yDif;
				for (var i = 1; i < yDif; i++){
					if (!(boardy.grid[position.y - i][position.x] instanceof Empty)){
						return false;
					}
				}
				if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
				return false;
			}
		} else if (position.y === endPosition.y){
		//horizontal movement
			
			var xDif = endPosition.x - position.x;
			if (xDif > 0){
				//moving right on board
				
				for (var i = 1; i < xDif; i++){
					if(!(boardy.grid[position.y][i + position.x] instanceof Empty)){
						return false;
					}
				}
				if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
				return false;
			} else {
				//moving left on board
				xDif = -1 * xDif;
				for (var i = 1; i < xDif; i++){
					if (!(boardy.grid[position.y][position.x - i] instanceof Empty)){
						return false;
					}
				}
				if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
				return false;
			}
		} else {
			return false;
		}
	};
}

function Horse(owner, position){
	this.owner = owner;
	this.position = position;
	this.validMove = function(endPosition){};
}

function Bishop(owner, position){
	this.owner = owner;
	this.position = position;
	this.validMove = function(endPosition){
		var yDif = endPosition.y - position.y;
		var xDif = endPosition.x - position.x;
		if (yDif > 0 && xDif > 0 && xDif === yDif){
			//up-right movement
			for (var i = 1; i < yDif; i++){
				if (!(boardy.grid[position.y + i][position.x + i] instanceof Empty)){
					return false;
				}
			}
			if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
			return false;
			
		} else if (yDif > 0 && xDif < 0 && xDif * -1 === yDif){
			//up-left movement
			
			for (var i = 1; i < yDif; i++){
				if (!(boardy.grid[position.y + i][position.x - i] instanceof Empty)){
					return false;
				}
			}
			if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
			return false;
			
		} else if (yDif < 0 && xDif < 0 && xDif === yDif){
			//down-left movement
			
			for (var i = 1; i < yDif * -1; i++){
				if (!(boardy.grid[position.y - i][position.x - i] instanceof Empty)){
					return false;
				}
			}
			if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
			return false;
			
		} else if (yDif < 0 && xDif > 0 && xDif === yDif * -1){
			//down-right movement
			
			for (var i = 1; i < xDif; i++){
				if (!(boardy.grid[position.y - i][position.x + i] instanceof Empty)){
					return false;
				}
			}
			if (boardy.grid[endPosition.y][endPosition.x].owner !== owner){
					return true;
				}
			return false;
		} else {
			return false;
		}
	};
}

function Queen(owner, position){
	this.owner = owner;
	this.position = position;
	this.validMove = function(endPosition){};
}

function King(owner, position){
	this.owner = owner;
	this.position = position;
	this.validMove = function(endPosition){};
}

function Pawn(owner, position){
	this.owner = owner;
	this.position = position;
	this.validMove = function(endPosition){
		if (owner === "white"){
			if (position.x === endPosition.x){
				//non attack move
				if (position.y + 1 === endPosition.y 
					&& boardy.grid[endPosition.y][endPosition.x] instanceof Empty){
					//normal move
					return true;
					
				} else if (position.y + 2 === endPosition.y 
							&& boardy.grid[endPosition.y - 1][endPosition.x] instanceof Empty
							&& boardy.grid[endPosition.y][endPosition.x] instanceof Empty
							&& position.y === 2){
					//special 2 space move
					return true;
				} else {
					return false;
				}
			} else if ((position.y + 1 === endPosition.y && position.x - 1 === endPosition.x) ||
						(position.y + 1 === endPosition.y && position.x + 1 === endPosition.x)){
				//attack move
				
				if (boardy.grid[endPosition.y][endPosition.x].owner === "black"){
					return true;
				} else {
					return false;
				}
			} else{
				return false;
			}
		} else { //owner is black
			if (position.x === endPosition.x){
				//non attack move
				
				if (position.y - 1 === endPosition.y 
					&& boardy.grid[endPosition.y][endPosition.x] instanceof Empty){
					//normal move
					return true;
					
				} else if (position.y - 2 === endPosition.y 
							&& boardy.grid[endPosition.y + 1][endPosition.x] instanceof Empty
							&& boardy.grid[endPosition.y][endPosition.x] instanceof Empty
							&& position.y === 7){
					//special 2 space move
					return true;
				} else {
					return false;
				}
			} else if ((position.y - 1 === endPosition.y && position.x - 1 === endPosition.x) ||
						(position.y - 1 === endPosition.y && position.x + 1 === endPosition.x)){
				//attack move
				
				if (boardy.grid[endPosition.y][endPosition.x].owner === "white"){
					return true;
				} else {
					return false;
				}
			} else{
				return false;
			}
		}
	};
}

function Empty(owner, board, position){
	this.board = board;
	this.owner = owner;
	this.position = position;
	this.validMove = function(){};
}

</script>

<!--
	<p id="8">8   R H B Q K B H R</p>
	<p id="7">7   P P P P P P P P</p>
	<p id="6">6   - - - - - - - -</p>
	<p id="5">5   - - - - - - - -</p>
	<p id="4">4   - - - - - - - -</p>
	<p id="3">3   - - - - - - - -</p>
	<p id="2">2   p p p p p p p p</p>
	<p id="1">1   r h b q k b h r</p>
	<p id="b">0   a b c d e f g h</p>

-->
</body>
</html>
